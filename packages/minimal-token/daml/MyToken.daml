module MyToken where

import DA.TextMap as TextMap

import Splice.Api.Token.HoldingV1 qualified as Api.Token.HoldingV1
import Splice.Api.Token.MetadataV1 qualified as Api.Token.MetadataV1

data TransferResult = TransferResult with
    transferredCid : ContractId MyToken
    remainderCid : Optional (ContractId MyToken)
  deriving (Show, Eq)

-- | TimeLock represents the lock metadata for locked tokens.
-- Follows the Amulet pattern from Splice.
data TimeLock = TimeLock with
    holders : [Party]
    expiresAt : Time
    lockContext : Optional Text
  deriving (Eq, Show)

-- Placeholder token instrument that will implement CIP-0056 holdings view.
data MyTokenKey = MyTokenKey
  with
    issuer : Party
    owner  : Party
    instrumentId : Text
  deriving (Eq, Show)

template MyToken
  with
    issuer : Party
    owner  : Party
    instrumentId : Text -- e.g., issuer <> "#MyToken"
    amount : Decimal
  where
    signatory issuer, owner

    interface instance Api.Token.HoldingV1.Holding for MyToken where
      view = Api.Token.HoldingV1.HoldingView with
        instrumentId = Api.Token.HoldingV1.InstrumentId with admin = issuer, id = instrumentId
        owner = owner
        amount = amount
        lock = None
        meta = myTokenMetadata this

    -- Note: No Lock choice - following Amulet pattern where locks are created
    -- declaratively by MyTokenRules during transfer preparation, not imperatively
    -- by exercising a choice on the token itself.

    choice MyToken_Transfer : TransferResult
      with
        receiver : Party
        amount: Decimal
      controller owner, receiver, issuer
      do
        assertMsg "Transfer amount must be less than or equal to current amount" (amount <= this.amount)
        assertMsg "Transfer amount must be greater than 0" (amount > 0.0)

        if amount == this.amount then do
          -- Full transfer
          resultCid <- create this with
            owner = receiver

          return TransferResult with
            transferredCid = resultCid
            remainderCid = None
        else do
          -- Partial transfer: create change back to current owner
          let remainderAmount = this.amount - amount
          remainderCid <- create this with
            amount = remainderAmount

          transferredCid <- create MyToken with
            issuer = this.issuer
            owner = receiver
            instrumentId = this.instrumentId
            amount

          return TransferResult with
            transferredCid
            remainderCid = Some remainderCid


myTokenMetadata : MyToken -> Api.Token.MetadataV1.Metadata
myTokenMetadata MyToken{..} =
  Api.Token.MetadataV1.Metadata with
    -- Empty for placeholder
    values = TextMap.fromList [ ]


-- | LockedMyToken wraps a MyToken with lock metadata.
-- Follows Amulet pattern: LockedAmulet wraps an Amulet value.
-- This avoids field duplication and makes the relationship explicit.
template LockedMyToken
  with
    token : MyToken      -- The wrapped token
    lock : TimeLock      -- Lock metadata
  where
    signatory lock.holders, signatory token

    interface instance Api.Token.HoldingV1.Holding for LockedMyToken where
      view = Api.Token.HoldingV1.HoldingView with
        instrumentId = Api.Token.HoldingV1.InstrumentId with admin = token.issuer, id = token.instrumentId
        owner = token.owner
        amount = token.amount
        -- Must expose lock details when token is locked (matches Amulet reference impl).
        -- See: https://github.com/global-synchronizer-foundation/cips/blob/main/cip-0056/cip-0056.md
        lock = Some (Api.Token.HoldingV1.Lock with
          holders = lock.holders
          expiresAt = Some lock.expiresAt
          expiresAfter = None
          context = lock.lockContext)
        meta = lockedMyTokenMetadata this

    choice Unlock : ContractId MyToken
      -- Following Amulet pattern: both owner and holders must authorize unlock
      controller token.owner :: lock.holders
      do
        create token

    choice OwnerExpireLock : ContractId MyToken
      -- Owner can reclaim after lock expires
      controller token.owner
      do
        assertDeadlineExceeded "Lock.expiresAt" lock.expiresAt
        create token

assertDeadlineExceeded : Text -> Time -> Update ()
assertDeadlineExceeded name deadline = do
  now <- getTime
  assertMsg (name <> " has not passed yet") (now > deadline)

lockedMyTokenMetadata : LockedMyToken -> Api.Token.MetadataV1.Metadata
lockedMyTokenMetadata LockedMyToken{..} =
  Api.Token.MetadataV1.Metadata with
    values = TextMap.fromList []
