module Bond.BondRules where

import DA.Time
import Splice.Api.Token.MetadataV1 as MD
import Splice.Api.Token.HoldingV1 as H
import Bond.Bond

-- | Minimal rules contract to assist with preparing two-step transfers by locking bond holdings.
template BondRules
  with
    issuer : Party
  where
    signatory issuer

    -- | Lock a single bond holding for a transfer.
    -- Following Amulet pattern: creates LockedBond directly, not via Lock choice.
    -- Requires both issuer (rules signatory) and the sender (owner) to authorize.
    -- Bonds cannot be split - only whole-unit transfers are allowed.
    -- Returns: (locked bond CID, None since bonds cannot be split, metadata)
    nonconsuming choice BondRules_LockForTransfer : (ContractId LockedBond, Optional (ContractId H.Holding), MD.Metadata)
      with
        sender : Party
        inputHoldingCid : ContractId H.Holding
        desiredAmount : Decimal
        transferBefore : Time
        contextText : Text
      controller sender
      do
        -- Treat input as an unlocked Bond (downcast from Holding)
        let bondCid : ContractId Bond = fromInterfaceContractId inputHoldingCid
        bond <- fetch bondCid
        assertMsg "Sender must be owner" (bond.owner == sender)
        assertMsg "desired amount must be positive" (desiredAmount > 0.0)
        -- Bonds cannot be split - only whole-unit transfers are allowed
        assertMsg "Transfer amount must equal bond principal. Bonds cannot be split - only whole-unit transfers are allowed" (desiredAmount == bond.principal)

        -- Archive original input
        archive bondCid

        -- Create locked bond (always full bond, no splitting)
        let lockedBond = Bond with
              issuer = bond.issuer
              depository = bond.depository
              owner = bond.owner
              instrumentId = bond.instrumentId
              version = bond.version
              principal = desiredAmount
              maturityDate = bond.maturityDate
              couponRate = bond.couponRate
              couponFrequency = bond.couponFrequency
              issueDate = bond.issueDate
              lastEventTimestamp = bond.lastEventTimestamp
        let lock = TimeLock with
              holders = [issuer]
              expiresAt = transferBefore
              lockContext = Some contextText
        lockedCid <- create LockedBond with
          bond = lockedBond
          lock = lock
        -- Always return None (no splitting)
        pure (lockedCid, None, MD.emptyMetadata)

    -- | Lock a bond for coupon payment processing.
    -- Controlled by holder (owner)
    -- When holder exercises this choice, issuer is in transaction as signatory of BondRules.
    -- Returns: (locked bond CID, None since we lock the full bond, metadata)
    nonconsuming choice BondRules_LockForCoupon : (ContractId LockedBond, Optional (ContractId H.Holding), MD.Metadata)
      with
        holder : Party
        inputBondCid : ContractId H.Holding
        couponPaymentDate : Time
        contextText : Text
      controller holder
      do
        -- Treat input as an unlocked Bond (downcast from Holding)
        let bondCid : ContractId Bond = fromInterfaceContractId inputBondCid
        bond <- fetch bondCid
        assertMsg "Holder must be owner" (bond.owner == holder)

        -- Archive original input
        -- Requires issuer, depository, and owner signatures (all signatories of bond).
        -- Issuer and holder authorize via controller, depository must also be in transaction.
        archive bondCid

        -- Create locked bond with coupon payment context
        -- For coupon payments, we always lock the full bond (no splitting)
        let lockedBond = Bond with
              issuer = bond.issuer
              depository = bond.depository
              owner = bond.owner
              instrumentId = bond.instrumentId
              version = bond.version
              principal = bond.principal
              maturityDate = bond.maturityDate
              couponRate = bond.couponRate
              couponFrequency = bond.couponFrequency
              issueDate = bond.issueDate
              lastEventTimestamp = bond.lastEventTimestamp
        let lock = TimeLock with
              holders = [issuer]
              expiresAt = addRelTime couponPaymentDate (days 30)  -- Reasonable expiry
              lockContext = Some contextText
        lockedCid <- create LockedBond with
          bond = lockedBond
          lock = lock
        pure (lockedCid, None, MD.emptyMetadata)

    -- | Lock a bond for principal redemption processing.
    -- Controlled by holder (owner)
    -- When holder exercises this choice, issuer is in transaction as signatory of BondRules.
    -- Returns: (locked bond CID, None since we lock the full bond, metadata)
    nonconsuming choice BondRules_LockForRedemption : (ContractId LockedBond, Optional (ContractId H.Holding), MD.Metadata)
      with
        holder : Party
        inputBondCid : ContractId H.Holding
        redemptionDate : Time
        contextText : Text
      controller holder
      do
        let bondCid : ContractId Bond = fromInterfaceContractId inputBondCid
        bond <- fetch bondCid
        assertMsg "Holder must be owner" (bond.owner == holder)

        now <- getTime
        assertMsg "Redemption date must be on or after maturity date" (redemptionDate >= bond.maturityDate)
        assertMsg "Redemption date must be in the past or present" (redemptionDate <= now)

        -- Archive original input
        -- Requires issuer, depository, and owner signatures (all signatories of bond).
        -- Issuer and holder authorize via controller, depository must also be in transaction.
        archive bondCid

        let lockedBond = Bond with
              issuer = bond.issuer
              depository = bond.depository
              owner = bond.owner
              instrumentId = bond.instrumentId
              version = bond.version
              principal = bond.principal
              maturityDate = bond.maturityDate
              couponRate = bond.couponRate
              couponFrequency = bond.couponFrequency
              issueDate = bond.issueDate
              lastEventTimestamp = bond.lastEventTimestamp
        let lock = TimeLock with
              holders = [issuer]
              expiresAt = addRelTime redemptionDate (days 30)
              lockContext = Some contextText
        lockedCid <- create LockedBond with
          bond = lockedBond
          lock = lock
        pure (lockedCid, None, MD.emptyMetadata)

