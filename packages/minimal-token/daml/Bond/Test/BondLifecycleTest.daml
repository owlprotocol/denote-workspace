module Bond.Test.BondLifecycleTest where

import Daml.Script
import DA.Time

import Bond.Bond (Bond, LockedBond)
import Bond.BondFactory as BondFactory
import Bond.BondRules as BondRules
import Bond.IssuerMintRequest as IssuerMintRequest
import Bond.TransferRequest as TransferRequest
import Bond.BondLifecycleClaimRequest as BondLifecycleClaimRequest
import Bond.BondLifecycleEffect
import Bond.BondLifecycleInstruction as BondLifecycleInstruction
import Bond.BondLifecycleRule as BondLifecycleRule
import Bond.BondTransferInstruction
import Bond.BondTransferFactory
import Splice.Api.Token.HoldingV1 as H
import Splice.Api.Token.TransferInstructionV1 as TI
import Splice.Api.Token.MetadataV1 as MD
import MyTokenRules
import MyTransferFactory
import MyTokenFactory
import MyToken
import MyToken.IssuerMintRequest as CurrencyMintRequest
import MyTokenTransferInstruction

-- | End-to-end test: mint → coupon payment (Alice) → transfer → redemption (Bob, includes final coupon)
testBondFullLifecycle : Script ()
testBondFullLifecycle = script do
  charlie <- allocatePartyByHint (PartyIdHint "Charlie")
  alice   <- allocatePartyByHint (PartyIdHint "Alice")
  bob     <- allocatePartyByHint (PartyIdHint "Bob")

  now <- getTime
  let instrumentId = show charlie <> "#Bond"
  let maturityDate = addRelTime now (days 365)  -- 1 year maturity
  let couponRate = 0.05  -- 5% annual
  let couponFrequency = 2  -- Semi-annual (2 payments per year)

  -- Setup: Charlie creates infrastructure

  rulesCid <- submit charlie do
    createCmd BondRules with issuer = charlie

  bondFactoryCid <- submit charlie do
    createCmd BondFactory with
      issuer = charlie
      instrumentId = instrumentId

  let currencyInstrumentId = show charlie <> "#Currency"
  currencyRulesCid <- submit charlie do
    createCmd MyTokenRules with issuer = charlie

  currencyTransferFactoryCid <- submit charlie do
    createCmd MyTransferFactory with
      registry = charlie
      rulesCid = currencyRulesCid

  currencyTokenFactoryCid <- submit charlie do
    createCmd MyTokenFactory with
      issuer = charlie
      instrumentId = currencyInstrumentId

  let currencyTransferFactoryInterfaceCid : ContractId TI.TransferFactory = toInterfaceContractId @TI.TransferFactory currencyTransferFactoryCid

  let currencyInstrumentIdHolding = H.InstrumentId with
        admin = charlie
        id = currencyInstrumentId
  lifecycleRuleCid <- submit charlie do
    createCmd BondLifecycleRule with
      issuer = charlie
      depository = charlie  -- Same as issuer for simplified test setup
      currencyInstrumentId = currencyInstrumentIdHolding

  -- Mint currency tokens for payments
  currencyMintRequestCid1 <- submit charlie do
    createCmd CurrencyMintRequest.IssuerMintRequest with
      tokenFactoryCid = currencyTokenFactoryCid
      issuer = charlie
      receiver = charlie
      amount = 25.0

  currencyMintResult1 <- submit charlie do
    exerciseCmd currencyMintRequestCid1 CurrencyMintRequest.Accept

  currencyMintRequestCid2 <- submit charlie do
    createCmd CurrencyMintRequest.IssuerMintRequest with
      tokenFactoryCid = currencyTokenFactoryCid
      issuer = charlie
      receiver = charlie
      amount = 1025.0

  currencyMintResult2 <- submit charlie do
    exerciseCmd currencyMintRequestCid2 CurrencyMintRequest.Accept

  let charlieCurrencyHoldingCid1 : ContractId H.Holding = toInterfaceContractId @H.Holding currencyMintResult1.tokenCid
  let charlieCurrencyHoldingCid2 : ContractId H.Holding = toInterfaceContractId @H.Holding currencyMintResult2.tokenCid

  -- Phase 1: Mint bond to Alice

  mintRequestCid <- submit alice do
    createCmd IssuerMintRequest.IssuerMintRequest with
      bondFactoryCid = bondFactoryCid
      issuer = charlie
      depository = charlie
      receiver = alice
      principal = 1000.0
      maturityDate = maturityDate
      couponRate = couponRate
      couponFrequency = couponFrequency

  mintResult <- submit charlie do
    exerciseCmd mintRequestCid IssuerMintRequest.Accept

  let aliceBondCid = mintResult.bondCid
  let aliceHolding : ContractId H.Holding = toInterfaceContractId @H.Holding aliceBondCid

  aliceBond <- queryContractId alice aliceBondCid
  initialVersion <- case aliceBond of
        Some bond -> do
          assertMsg "Initial version should be 0" (bond.version == "0")
          assertMsg "Principal should be 1000" (bond.principal == 1000.0)
          assertMsg "Alice should be owner" (bond.owner == alice)
          pure bond.version
        None -> error "Alice's bond not found"

  -- Phase 2: First coupon payment to Alice (6 months)
  passTime (days 182)

  effectCid1 <- submit charlie do
    exerciseCmd lifecycleRuleCid BondLifecycleRule.ProcessCouponPaymentEvent with
      targetInstrumentId = instrumentId
      targetVersion = initialVersion
      couponRate = couponRate
      couponFrequency = couponFrequency
      principalPerUnit = 1000.0

  Some effect1 <- queryContractId @BondLifecycleEffect charlie effectCid1
  let couponPaymentDate1 = effect1.eventDate

  bondFactoryDisclosure <- do
    optDisc <- queryDisclosure @BondFactory charlie bondFactoryCid
    case optDisc of
      Some d -> pure d
      None -> fail "BondFactory disclosure not found"

  claimRequestCid1 <- submit alice do
    createCmd BondLifecycleClaimRequest.BondLifecycleClaimRequest with
      effectCid = effectCid1
      bondHoldingCid = aliceHolding
      bondRulesCid = rulesCid
      bondFactoryCid = bondFactoryCid
      currencyTransferFactoryCid = currencyTransferFactoryInterfaceCid
      issuerCurrencyHoldingCid = charlieCurrencyHoldingCid1
      holder = alice
      issuer = charlie

  claimResult1 <- submit charlie do
    exerciseCmd claimRequestCid1 BondLifecycleClaimRequest.Accept

  let (instructionCid1, couponAmount1, currencyTransferCidOpt1) = case claimResult1 of
        ClaimResult_CouponPayment result -> (result.instructionCid, result.couponAmount, result.currencyTransferInstructionCid)
        ClaimResult_Redemption _ -> error "Expected coupon payment result, got redemption result"

  assertMsg "Coupon amount should be 25.0" (couponAmount1 == 25.0)

  processResult1 <- submitWithDisclosures alice [bondFactoryDisclosure] do
    exerciseCmd instructionCid1 BondLifecycleInstruction.Process

  let newBondCid1 = case processResult1 of
        CouponPaymentResult_ result -> result.newBondCid
        RedemptionResult_ _ -> error "Expected coupon payment result, got redemption result"
  newBond1 <- queryContractId alice newBondCid1
  versionAfterCoupon1 <- case newBond1 of
        Some bond -> do
          assertMsg "Version should change after first coupon" (bond.version /= initialVersion)
          assertMsg "Principal should still be 1000" (bond.principal == 1000.0)
          assertMsg "lastEventTimestamp should be updated" (bond.lastEventTimestamp == couponPaymentDate1)
          pure bond.version
        None -> error "New bond after first coupon not found"

  case currencyTransferCidOpt1 of
    Some currencyTransferCid1 -> do
      Some currencyInstr1 <- queryContractId @MyTransferInstruction charlie (coerceContractId currencyTransferCid1)
      lockedTokenDisclosure1 <- do
        optDisc <- queryDisclosure @MyToken.LockedMyToken charlie currencyInstr1.lockedMyToken
        case optDisc of
          Some d -> pure d
          None -> fail "Locked token disclosure not found"

      currencyTransferResult1 <- submitWithDisclosures alice [lockedTokenDisclosure1] do
        exerciseCmd currencyTransferCid1 TI.TransferInstruction_Accept with
          extraArgs = MD.ExtraArgs with
            context = MD.emptyChoiceContext
            meta = MD.emptyMetadata

      case currencyTransferResult1.output of
        TI.TransferInstructionResult_Completed { receiverHoldingCids } -> do
          case receiverHoldingCids of
            [aliceCurrencyHoldingCid1] -> do
              let aliceCurrencyTokenCid1 : ContractId MyToken = fromInterfaceContractId aliceCurrencyHoldingCid1
              aliceCurrencyToken1 <- queryContractId alice aliceCurrencyTokenCid1
              case aliceCurrencyToken1 of
                Some token -> assertMsg "Alice should receive 25.0 currency tokens" (token.amount == 25.0 && token.owner == alice)
                None -> error "Alice's currency token not found"
            _ -> error "Expected exactly one currency holding"
        _ -> error "Currency transfer should be completed"
    None -> error "Currency transfer instruction should be created"

  -- Phase 3: Alice transfers full bond to Bob
  passTime (days 1)

  rulesDisclosure <- do
    optDisc <- queryDisclosure @BondRules charlie rulesCid
    case optDisc of
      Some d -> pure d
      None -> fail "BondRules disclosure not found"

  bondTransferFactoryCid <- submit charlie do
    createCmd BondTransferFactory with
      registry = charlie
      rulesCid = rulesCid

  let transferBefore = addRelTime now (days 400)
  let aliceHoldingAfterCoupon1 : ContractId H.Holding = toInterfaceContractId @H.Holding newBondCid1
  let transfer = TI.Transfer with
        sender = alice
        receiver = bob
        amount = 1000.0
        instrumentId = H.InstrumentId with admin = charlie; id = instrumentId
        requestedAt = addRelTime now (seconds (-1))
        executeBefore = transferBefore
        inputHoldingCids = [aliceHoldingAfterCoupon1]
        meta = MD.emptyMetadata

  transferRequestCid <- submit alice do
    createCmd TransferRequest.TransferRequest with
      transferFactoryCid = bondTransferFactoryCid
      expectedAdmin = charlie
      transfer = transfer
      extraArgs = MD.ExtraArgs with
        context = MD.emptyChoiceContext
        meta = MD.emptyMetadata

  transferResult <- submit charlie do
    exerciseCmd transferRequestCid TransferRequest.Accept

  let transferInstructionCid = case transferResult.output of
        TI.TransferInstructionResult_Pending { transferInstructionCid } -> transferInstructionCid
        _ -> error "Transfer instruction should be pending"

  assertMsg "No change expected for whole-unit transfer" (length transferResult.senderChangeCids == 0)

  Some instr <- queryContractId @BondTransferInstruction charlie (coerceContractId transferInstructionCid)
  Some transferDisclosure <- queryDisclosure @LockedBond charlie instr.lockedBond

  transferCompleteResult <- submitWithDisclosures bob [transferDisclosure] do
    exerciseCmd transferInstructionCid TI.TransferInstruction_Accept with
      extraArgs = MD.ExtraArgs with
        context = MD.emptyChoiceContext
        meta = MD.emptyMetadata

  (bobBondHolding, bobBondCid) <- case transferCompleteResult.output of
        TI.TransferInstructionResult_Completed { receiverHoldingCids } -> do
          assertMsg "Bob should receive one bond holding" (length receiverHoldingCids == 1)
          case receiverHoldingCids of
            [bobHolding] -> do
              let bobBondCid : ContractId Bond = fromInterfaceContractId bobHolding
              bobBond <- queryContractId bob bobBondCid
              case bobBond of
                Some bond -> do
                  assertMsg "Bob's bond should have 1000 principal" (bond.principal == 1000.0)
                  assertMsg "Bob should be owner" (bond.owner == bob)
                  assertMsg "Version should be preserved from transfer" (bond.version == versionAfterCoupon1)
                None -> error "Bob's bond not found"
              pure (bobHolding, bobBondCid)
            _ -> error "Expected exactly one bond holding for Bob"
        _ -> error "Transfer should be completed"

  aliceBondAfterTransfer <- queryContractId alice newBondCid1
  case aliceBondAfterTransfer of
    Some _ -> error "Alice should not have a bond after full transfer"
    None -> pure ()

  -- Phase 4: Redemption at maturity (includes final coupon)
  passTime (days 183)

  effectCid2 <- submit charlie do
    exerciseCmd lifecycleRuleCid BondLifecycleRule.ProcessRedemptionEvent with
      targetInstrumentId = instrumentId
      targetVersion = versionAfterCoupon1
      principalPerUnit = 1000.0
      couponRate = couponRate
      couponFrequency = couponFrequency

  Some effect2 <- queryContractId @BondLifecycleEffect charlie effectCid2
  let redemptionDate = effect2.eventDate

  claimRequestCid2 <- submit bob do
    createCmd BondLifecycleClaimRequest.BondLifecycleClaimRequest with
      effectCid = effectCid2
      bondHoldingCid = bobBondHolding
      bondRulesCid = rulesCid
      bondFactoryCid = bondFactoryCid
      currencyTransferFactoryCid = currencyTransferFactoryInterfaceCid
      issuerCurrencyHoldingCid = charlieCurrencyHoldingCid2
      holder = bob
      issuer = charlie

  claimResult2 <- submit charlie do
    exerciseCmd claimRequestCid2 BondLifecycleClaimRequest.Accept

  let (instructionCid2, redemptionAmount2, currencyTransferCidOpt2) = case claimResult2 of
        ClaimResult_Redemption result -> (result.instructionCid, result.principalAmount, result.currencyTransferInstructionCid)
        ClaimResult_CouponPayment _ -> error "Expected redemption result, got coupon payment result"

  assertMsg "Redemption amount should be 1025.0 (principal + final coupon)" (redemptionAmount2 == 1025.0)

  processResult2 <- submit bob do
    exerciseCmd instructionCid2 BondLifecycleInstruction.Process

  let redemptionAmountFromResult = case processResult2 of
        RedemptionResult_ result -> result.principalAmount
        CouponPaymentResult_ _ -> error "Expected redemption result, got coupon payment result"

  assertMsg "Redemption amount should be 1025.0 (principal + final coupon)" (redemptionAmountFromResult == 1025.0)

  oldBond <- queryContractId bob bobBondCid
  case oldBond of
    Some _ -> error "Bond should be archived after redemption"
    None -> pure ()

  case currencyTransferCidOpt2 of
    Some currencyTransferCid2 -> do
      Some currencyInstr2 <- queryContractId @MyTransferInstruction charlie (coerceContractId currencyTransferCid2)
      lockedTokenDisclosure2 <- do
        optDisc <- queryDisclosure @MyToken.LockedMyToken charlie currencyInstr2.lockedMyToken
        case optDisc of
          Some d -> pure d
          None -> fail "Locked token disclosure not found"

      currencyTransferResult2 <- submitWithDisclosures bob [lockedTokenDisclosure2] do
        exerciseCmd currencyTransferCid2 TI.TransferInstruction_Accept with
          extraArgs = MD.ExtraArgs with
            context = MD.emptyChoiceContext
            meta = MD.emptyMetadata

      case currencyTransferResult2.output of
        TI.TransferInstructionResult_Completed { receiverHoldingCids } -> do
          case receiverHoldingCids of
            [bobCurrencyHoldingCid2] -> do
              let bobCurrencyTokenCid2 : ContractId MyToken = fromInterfaceContractId bobCurrencyHoldingCid2
              bobCurrencyToken2 <- queryContractId bob bobCurrencyTokenCid2
              case bobCurrencyToken2 of
                Some token -> assertMsg "Bob should receive 1025.0 currency tokens (principal + final coupon)" (token.amount == 1025.0 && token.owner == bob)
                None -> error "Bob's currency token not found"
            _ -> error "Expected exactly one currency holding"
        _ -> error "Currency transfer should be completed"
    None -> error "Currency transfer instruction should be created"

  pure ()

