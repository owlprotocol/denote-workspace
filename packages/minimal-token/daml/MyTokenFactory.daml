module MyTokenFactory where

import MyToken
import Splice.Api.Token.MetadataV1 as MD

-- | A factory for minting MyToken tokens.
-- Allows issuer-controlled minting where both issuer and receiver sign during mint.
-- This enables TransferFactory to mint and lock tokens atomically.
-- Pattern matches Splice AmuletRules_Mint choice behavior.
template MyTokenFactory
  with
    issuer : Party
    instrumentId : Text -- e.g., show issuer <> "#MyToken"
  where
    signatory issuer

    -- | Mint tokens to a receiver.
    -- Requires both issuer and receiver to sign (controller issuer, receiver)
    -- This allows issuer to initiate mints while ensuring receiver authorization.
    nonconsuming choice Mint : MintResult
      with
        receiver : Party
        amount : Decimal
      controller issuer, receiver
      do
        assertMsg "Amount must be positive" (amount > 0.0)

        tokenCid <- create MyToken with
          issuer
          owner = receiver
          instrumentId = instrumentId
          amount = amount

        pure MintResult with
          tokenCid
          meta = MD.emptyMetadata

    nonconsuming choice Burn : BurnResult
      with
        owner : Party
        amount : Decimal
        -- ^ Amount of tokens to burn
        inputHoldingCid : ContractId MyToken
        -- ^ Token contract to use as input. Will be split if needed to get the burn amount.
      controller issuer, owner
      do
        assertMsg "Amount must be positive" (amount > 0.0)

        -- Validate input token
        inputToken <- fetch inputHoldingCid
        assertMsg "Token owner must match" (inputToken.owner == owner)
        assertMsg "Token issuer must match factory issuer" (inputToken.issuer == issuer)
        assertMsg "Token instrument ID must match" (inputToken.instrumentId == instrumentId)
        assertMsg "Insufficient tokens to burn" (inputToken.amount >= amount)

        -- Split and burn: use a self-transfer to split off the exact amount, then archive it
        -- This follows the splice splitAndBurn pattern
        if inputToken.amount == amount then do
          -- Exact match: archive the entire token
          archive inputHoldingCid
          pure BurnResult with
            burnedCids = [inputHoldingCid]
            meta = MD.emptyMetadata
        else do
          transferResult <- exercise inputHoldingCid MyToken_Transfer with
            receiver = owner
            amount = amount
          -- Archive the newly created token (the transferred portion to be burned)
          archive transferResult.transferredCid
          pure BurnResult with
            burnedCids = [transferResult.transferredCid]
            meta = MD.emptyMetadata

-- | Result of minting tokens
data MintResult = MintResult with
    tokenCid : ContractId MyToken
    meta : MD.Metadata
  deriving (Show, Eq)

-- | Result of burning tokens
data BurnResult = BurnResult with
    burnedCids : [ContractId MyToken]
    meta : MD.Metadata
  deriving (Show, Eq)

