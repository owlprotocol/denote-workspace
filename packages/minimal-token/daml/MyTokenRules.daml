module MyTokenRules where

import Splice.Api.Token.MetadataV1 as MD
import Splice.Api.Token.HoldingV1 as H
import MyToken

-- | Minimal rules contract to assist with preparing two-step transfers by locking holdings.
template MyTokenRules
  with
    issuer : Party
  where
    signatory issuer

    -- | Lock a single holding for a transfer.
    -- Following Amulet pattern: creates LockedMyToken directly, not via Lock choice.
    -- Requires both issuer (rules signatory) and the sender (owner) to authorize.
    -- Returns: (locked token CID, sender change CID if split occurred, metadata)
    nonconsuming choice MyTokenRules_LockForTransfer : (ContractId LockedMyToken, Optional (ContractId H.Holding), MD.Metadata)
      with
        sender : Party
        inputHoldingCid : ContractId H.Holding
        desiredAmount : Decimal
        transferBefore : Time
        contextText : Text
      controller sender
      do
        -- Treat input as an unlocked MyToken (downcast from Holding)
        let tokenCid : ContractId MyToken = fromInterfaceContractId inputHoldingCid
        token <- fetch tokenCid
        assertMsg "Sender must be owner" (token.owner == sender)
        assertMsg "desired amount must be positive" (desiredAmount > 0.0)

        -- Archive original input
        archive tokenCid

        if token.amount == desiredAmount then do
          -- Create locked token directly (no change needed)
          let lockedToken = MyToken with
                issuer = token.issuer
                owner = token.owner
                instrumentId = token.instrumentId
                amount = desiredAmount
          let lock = TimeLock with
                holders = [issuer]
                expiresAt = transferBefore
                lockContext = Some contextText
          lockedCid <- create LockedMyToken with
            token = lockedToken
            lock = lock
          pure (lockedCid, None, MD.emptyMetadata)
        else if token.amount > desiredAmount then do
          -- Split: create change for sender and locked token
          let changeAmount = token.amount - desiredAmount

          -- Create change back to sender
          changeCid : ContractId MyToken <- create MyToken with
            issuer = token.issuer
            owner = token.owner
            instrumentId = token.instrumentId
            amount = changeAmount

          -- Create locked token with desired amount
          let lockedToken = MyToken with
                issuer = token.issuer
                owner = token.owner
                instrumentId = token.instrumentId
                amount = desiredAmount
          let lock = TimeLock with
                holders = [issuer]
                expiresAt = transferBefore
                lockContext = Some contextText
          lockedCid <- create LockedMyToken with
            token = lockedToken
            lock = lock
          let changeHoldingCid : ContractId H.Holding = toInterfaceContractId @H.Holding changeCid
          pure (lockedCid, Some changeHoldingCid, MD.emptyMetadata)
        else
          fail "Insufficient amount to lock the desired amount"


