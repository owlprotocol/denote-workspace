module MyTokenRules where

import Splice.Api.Token.MetadataV1 as MD
import Splice.Api.Token.HoldingV1 as H
import MyToken

-- | Minimal rules contract to assist with preparing two-step transfers by locking holdings.
template MyTokenRules
  with
    issuer : Party
  where
    signatory issuer

    -- | Lock a single holding for a transfer.
    -- Requires both issuer (rules signatory) and the sender (owner) to authorize.
    nonconsuming choice MyTokenRules_LockForTransfer : (ContractId LockedMyToken, MD.Metadata)
      with
        sender : Party
        inputHoldingCid : ContractId H.Holding
        desiredAmount : Decimal
        transferBefore : Time
        contextText : Text
      controller sender
      do
        -- Treat input as an unlocked MyToken (downcast from Holding)
        let tokenCid : ContractId MyToken = fromInterfaceContractId inputHoldingCid
        token <- fetch tokenCid
        assertMsg "Sender must be owner" (token.owner == sender)
        assertMsg "desired amount must be positive" (desiredAmount > 0.0)
        if token.amount == desiredAmount then do
          -- Lock the existing token as-is
          lockedCid <- exercise tokenCid MyToken.Lock with
            holders = [issuer]
            expiresAt = transferBefore
            MyToken.lockContext = Some contextText
          pure (lockedCid, MD.emptyMetadata)
        else if token.amount > desiredAmount then do
          -- Split: archive original; create change and a fresh token of desiredAmount; lock the fresh one
          -- Create change for the remainder
          let changeAmount = token.amount - desiredAmount
          -- Archive original input
          archive tokenCid
          -- Create change back to sender
          _changeCid : ContractId MyToken <- create MyToken with
            issuer = token.issuer
            owner = token.owner
            instrumentId = token.instrumentId
            amount = changeAmount
          -- Create the exact-amount token to lock
          exactCid : ContractId MyToken <- create MyToken with
            issuer = token.issuer
            owner = token.owner
            instrumentId = token.instrumentId
            amount = desiredAmount
          lockedCid <- exercise exactCid MyToken.Lock with
            holders = [issuer]
            expiresAt = transferBefore
            MyToken.lockContext = Some contextText
          pure (lockedCid, MD.emptyMetadata)
        else
          fail "Insufficient amount to lock the desired amount"


