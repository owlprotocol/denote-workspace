module ETF.MyMintRequest where

import DA.Foldable (forA_)

import Splice.Api.Token.MetadataV1 as MD
import Splice.Api.Token.TransferInstructionV1 as TI

import ETF.MyMintRecipe as MyMintRecipe
import ETF.PortfolioComposition (PortfolioItem)
import MyToken

template MyMintRequest
  with
    mintRecipeCid: ContractId MyMintRecipe
    -- ^ The mint recipe to be used for minting
    requester: Party
    -- ^ The party requesting the minting
    amount: Decimal
    -- ^ The amount of ETF tokens to mint
    transferInstructionCids: [ContractId TI.TransferInstruction]
    -- ^ The transfer instructions to be executed as part of the minting process. Expected to be in the same order as the portfolio composition.
    issuer:Party
    -- ^ The ETF issuer

  where
    signatory requester
    observer issuer

    ensure amount > 0.0

    choice MintRequest_Accept : ContractId MyToken
      -- ^ Accept the mint request and mint the tokens.
      controller issuer
      do
        mintRecipe <- fetch mintRecipeCid
        portfolioComp <- fetch (mintRecipe.composition)

        assertMsg "Mint recipe requester must be an authorized minter" (requester `elem` mintRecipe.authorizedMinters)

        assertMsg "Transfer instructions must be of same length as portfolio composition items" $ (length transferInstructionCids) == (length portfolioComp.items)

        forA_ (zip transferInstructionCids portfolioComp.items) $
          \(tiCid, portfolioItem) -> validateTransferInstruction tiCid portfolioItem amount issuer requester
        -- For each transfer instruction:
        -- Accept each transfer instruction
        forA_ transferInstructionCids $
          \tiCid -> exercise tiCid TI.TransferInstruction_Accept with
            extraArgs = MD.ExtraArgs with
              context = MD.emptyChoiceContext
              meta = MD.emptyMetadata

        exercise mintRecipeCid MyMintRecipe.MyMintRecipe_Mint with
          receiver = requester
          amount = amount

    choice MintRequest_Decline : ()
      -- ^ Decline the request.
      controller issuer
      do
        pure ()

    choice MintRequest_Withdraw : ()
      -- ^ Withdraw the request.
      controller requester
      do
        pure ()


validateTransferInstruction : ContractId TI.TransferInstruction -> PortfolioItem -> Decimal -> Party -> Party -> Update ()
validateTransferInstruction tiCid portfolioItem amount issuer requester = do
  ti <- fetch tiCid

  let tiView = view ti

  assertMsg "Transfer instruction sender does not match requester" (tiView.transfer.sender == requester)

  assertMsg "Transfer instruction receiver does not match issuer" (tiView.transfer.receiver == issuer)
  assertMsg ("Transfer instruction instrumentId does not match portfolio item: " <> show tiView.transfer.instrumentId <> ", " <> show portfolioItem.instrumentId) (tiView.transfer.instrumentId == portfolioItem.instrumentId)
  assertMsg "Transfer instruction amount does not match expected amount" (tiView.transfer.amount == (portfolioItem.weight * amount))
