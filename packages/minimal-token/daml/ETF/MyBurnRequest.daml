module ETF.MyBurnRequest where

import DA.Foldable (forA_)

import Splice.Api.Token.TransferInstructionV1 as TI
import Splice.Api.Token.MetadataV1 as MD

import ETF.MyMintRecipe
import ETF.PortfolioComposition (PortfolioItem)
import MyToken
import MyTokenFactory

template MyBurnRequest
  with
    mintRecipeCid: ContractId MyMintRecipe
    -- ^ The mint recipe to be used for burning
    requester: Party
    -- ^ The party requesting the burning
    amount: Decimal
    tokenFactoryCid: ContractId MyTokenFactory
    -- ^ The amount of ETF tokens to burn
    inputHoldingCid: ContractId MyToken
    -- ^ The token holding to use as input. Will be split if needed.
    issuer: Party
    -- ^ The ETF issuer
  where
    signatory requester
    observer issuer

    ensure amount > 0.0

    choice BurnRequest_Accept : BurnResult
      -- ^ Accept the burn request and burn the tokens.
      with
        transferInstructionCids: [ContractId TI.TransferInstruction]
        -- ^ The transfer instructions to be executed as part of the burning process. Expected to be in the same order as the portfolio composition
      controller issuer
      do
        mintRecipe <- fetch mintRecipeCid
        portfolioComp <- fetch (mintRecipe.composition)

        assertMsg "Transfer instructions must be of same length as portfolio composition items" $ (length transferInstructionCids) == (length portfolioComp.items)

        forA_ (zip transferInstructionCids portfolioComp.items) $
          \(tiCid, portfolioItem) -> validateTransferInstruction tiCid portfolioItem amount issuer requester
        -- For each transfer instruction:
        -- Accept each transfer instruction
        forA_ transferInstructionCids $
          \tiCid -> exercise tiCid TI.TransferInstruction_Accept with
            extraArgs = MD.ExtraArgs with
              context = MD.emptyChoiceContext
              meta = MD.emptyMetadata

        exercise tokenFactoryCid MyTokenFactory.Burn with
          owner = requester
          amount = amount
          inputHoldingCid = inputHoldingCid


    choice BurnRequest_Decline : ()
      -- ^ Decline the request.
      controller issuer
      do
        pure ()

    choice BurnRequest_Withdraw : ()
      -- ^ Withdraw the request.
      controller requester
      do
        pure ()

validateTransferInstruction : ContractId TI.TransferInstruction -> PortfolioItem -> Decimal -> Party -> Party -> Update ()
validateTransferInstruction tiCid portfolioItem amount issuer requester = do
  ti <- fetch tiCid

  let tiView = view ti

  assertMsg "Transfer instruction sender does not match issuer" (tiView.transfer.sender == issuer)

  assertMsg "Transfer instruction receiver does not match requester" (tiView.transfer.receiver == requester)
  assertMsg ("Transfer instruction instrumentId does not match portfolio item: " <> show tiView.transfer.instrumentId <> ", " <> show portfolioItem.instrumentId) (tiView.transfer.instrumentId == portfolioItem.instrumentId)
  assertMsg "Transfer instruction amount does not match expected amount" (tiView.transfer.amount == (portfolioItem.weight * amount))
